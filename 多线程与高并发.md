# 多线程与高并发

### 1 .关键方法和关键字

##### 1.1 CAS

>CompareAndSwap无锁机制的比较交换。
>
>------------------
>
>原理：是读取内存中的值，然后根据该值去更新新值，最后写入内存，在写入内存之前，再次拿到内存中的值，看下该值是否被其他线程改变，如果被其他线程改变，则重新获取改变后的值，自己重新计算，再去尝试写入内存，直到内存中的值和自己拿到的值是一致的，才去写入内存。

> 存在的问题？
>
> -------
>
> 1、ABA问题
>
> 当线程拿到内存中数据为A，修改完值之后写入内存的时候，这时内存中的值被其他线程改了两次，由A改到B，再由B改到A，此时的A已经不是原始的A了，如果根据业务，必须需要知道是不是原来的A，就需要读取值的版本号，以此来解决ABA问题。
>
> 2、有没有可能两个线程同时写入内存，然后发生并发问题。
>
> 没有可能，因为CAS底层是汇编语言，最后的执行指令是 lock cmpxchg，最后的指令是机器加了锁的。
>
> 3、性能问题
>
> 如果该值频繁的被改，自己频繁的自旋比较，还是比较损耗新能的。

##### 1.2 锁消除

>锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。锁削除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。

###### 锁消除的前提：

>java虚拟机需要开启两个参数

```YML
#开启逃逸分析
-XX:+DoEscapeAnalysis
#表示锁消除
-XX:+EliminateLocks  
```

##### 1.3 JIT

> JUST-IN-TIME 即时编译器
>
> ------
>
> 狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。*JIT编译是动态编译的一种特例*。JIT编译一词后来被*泛化*，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别。

###### 热点代码

> 在部分商用虚拟机中（如HotSpot），Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“*热点代码*”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为*即时编译器*（Just In Time Compiler，下文统称JIT编译器）。

##### 1.4 锁升级

<img src="E:\学习\java技术\高并发\锁升级.png" alt="锁升级" style="zoom:150%;" />

##### 1.5 synchronized

> 代码层面：添加synchronized关键字
>
> 编译层面：增加MONITORENTER和MONITOREXIT，监视器
>
> 执行过程：锁自动升级（1.4锁升级图）
>
> CPU汇编层级：lock cmpxchg(锁住北桥的信号)

##### 1.6 volatile

> 1. 保证线程可见性。



